
一般采用绑定方法函数(也称为`事件处理器`)的方式来处理事件。

事件处理器的值可以是:
- `内联事件处理器`: 事件被触发时执行的内联 JavaScript 语句(即 js 代码在 .vue 中)
- `方法事件处理器`: 一个指向组件上定义的方法的属性名或是路径

### 内联事件处理器

例如像下面这样的书写，对 count 变量的计算就是按内联方式处理的:
```html
  <button @click="count++">Add</button>
```

- [基于vue-cli的内联事件处理器示例](vu-1)

### 方法事件处理器

多事件处理是指对于同一个用户交互事件，需要调用多个方法进行处理。

在 Vue 中绑定事件时支持使用逗号对多个函数进行调用绑定。比如点击事件关联两个功能: 计数和打印:
```js
  methods: {
    click(step) {
      this.count += step
    },
    log(event) {
      console.log(event)
    }
  }
```
如果要进行多事件处理，在绑定事件时都要采用内联调用的方式绑定:
```html
  <button @click="click(2), log($event)">点击</button>
```

- [基于vue-cli的方法事件处理器示例](vu-2)

### 事件传参

当没有为事件传递参数时，系统会自动将当前的 Event 对象传递到函数中去:
```js
  click(event) {
    this.count += 1
  }
```
Event 对象中会存储当前事件的很多信息，例如事件类型、鼠标位置、键盘按键情况等。

也可以为事件传入自定义的参数:
```js
  click(step) {
    this.count += step
  }
```
这样，在进行事件绑定时，可以采用内联处理的方式设置函数的参数:
```html
  <button @click="click(2)">点击</button>
```

如果在自定义传参的基础上，需要使用系统的 Event 对象参数，可以使用 `$event` 来传递此参数:
```js
  click(step, event) {
    console.log(event)
    this.count += step
  }
```
可以像下面这样绑定事件:
```html
  <button @click="click(2, $event)"></button>
```

- [基于vue-cli的事件传参示例](vu-3)

### 事件修饰符

当在页面上触发了一个单击事件时，事件首先会从当前组件开始依次传递到其内层组件，这一过程称为`事件捕获`，当事件传递到最内层组件时，其还会逆向地再进行一轮传递，从这个子组件依次向外传递，这一过程被称为`事件冒泡`。Vue 中使用 `@click` 的方式绑定事件时，默认监听的是 DOM 事件的冒泡阶段，即从内层组件传递到外层组件的这一过程。

[事件冒泡示例](t/01_bubble.html)

如果要监听捕获阶段的事件，就需要使用事件修饰符。事件修饰符`capture`可以将监听事件设置为捕获阶段。

[事件捕获示例](t/01_capture.html)

在实际应用中，可以根据具体的需求来选择要使用冒泡事件还是捕获事件。

利用 `stop` 修饰符可以阻止事件的传递。这样在单击时，只有被单击的当前组件绑定的方法会被调用。

[stop修饰符示例](t/01_stop.html)

这里汇总一些常用的事件修饰符:

| 事件修饰符 | 作用 |
|:----------|:-----|
| stop | 阻止事件传递 |
| capture | 监听捕获场景的事件 |
| once | 只触发一次事件 |
| self | 当事件对象的 target 属性是当前组件时才触发事件 |
| prevent | 禁止默认的事件 |
| passive | 不禁止默认事件 |

事件修饰符可以串联使用，例如下面的写法既能起到阻止事件传递的作用，又能控制只能触发一次事件:
```html
  <div @click.stop.once="click">点击</div>
```

利用事件修饰符，可以让开发者更专注于数据逻辑而不用去处理 DOM 事件的细节。

- [基于vue-cli的事件修饰符示例](vu-4)

对于键盘按键事件来说，Vue 中定义了一组按钮别名事件修饰符。
